---
layout: post
title: JVM class file format
tags: jvm java
---

I received [Java Virtual Machine Specification](https://www.amazon.com/gp/product/013390590X/ref=oh_aui_detailpage_o00_s00?ie=UTF8&psc=1) approximately a week ago. I had been waiting for it three weeks so I started read it immediately. Reading the other chapter of the specification I realized that I start understand how `JVM` works and why it works in such a way. For better understanding I am going to write a few articles about it. I will start from looking at generated byte code by `javac` and how it interpreted by `java` runtime. In this article, I am going to describe the `class` file format in short.

# Say hello to byte code

Start is always hard, let's start from the beginning, let's start from the "Hello, world!" example.

```java
public class HelloWorld {
    public static void main(String[] args) {
        new HelloWorld().sayHello();
    }

    private void sayHello() {
    }
}
```

To see the byte code instructions of the below class you need to compile it with `javac` and then run `javap` as the follows:

```sh
$ javac HelloWorld.java
$ javap -c -p -v HelloWorld.class > HelloWorld.bc
```

> `javap` prints byte code instructions to the standard output, so I transfered output into the file called `HelloWorld.bc`. You can call it as you with and with any extension or none. It just convenient to me `.java` - source code, `.class` - compiled class, `.bc` - byte code representation.

The result of above commands is the following

```
Classfile /Users/alex-diez/Projects/jvm-internals/HelloWorld.class
  Last modified Apr 2, 2017; size 344 bytes
  MD5 checksum 25a868af9590095c294cae89fbb9d195
  Compiled from "HelloWorld.java"
public class HelloWorld
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #5.#15         // java/lang/Object."<init>":()V
   #2 = Class              #16            // HelloWorld
   #3 = Methodref          #2.#15         // HelloWorld."<init>":()V
   #4 = Methodref          #2.#17         // HelloWorld.sayHello:()V
   #5 = Class              #18            // java/lang/Object
   #6 = Utf8               <init>
   #7 = Utf8               ()V
   #8 = Utf8               Code
   #9 = Utf8               LineNumberTable
  #10 = Utf8               main
  #11 = Utf8               ([Ljava/lang/String;)V
  #12 = Utf8               sayHello
  #13 = Utf8               SourceFile
  #14 = Utf8               HelloWorld.java
  #15 = NameAndType        #6:#7          // "<init>":()V
  #16 = Utf8               HelloWorld
  #17 = NameAndType        #12:#7         // sayHello:()V
  #18 = Utf8               java/lang/Object
{
  public HelloWorld();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1       // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 1: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: new           #2       // class HelloWorld
         3: dup
         4: invokespecial #3       // Method "<init>":()V
         7: invokespecial #4       // Method sayHello:()V
        10: return
      LineNumberTable:
        line 3: 0
        line 4: 10

  private void sayHello();
    descriptor: ()V
    flags: ACC_PRIVATE
    Code:
      stack=0, locals=1, args_size=1
         0: return
      LineNumberTable:
        line 7: 0
}
SourceFile: "HelloWorld.java"
```

First four lines provide information about the path to `.class` file on you computer, last modification date, size, md5 checksum and `.java` source file name. Then you can see class name, major and minor versions and class's flags. Constant pool is used by the `JVM` to resolve classes, methods, method's argument types, store primitive and `String` constants. I will describe it in more details in future posts. 

Let start with `HelloWrold` constructor. 

```
  public HelloWorld();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1       // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 1: 0
```

You may notice that I haven't written constructor for `HelloWorld` class, however, `javac` made it for me. The `descriptor` shows that it is a method that _does not accept parameters_ and return `void` that presented by `V` symbol. You may notice that `args_size` is actually equal to 1. Constructors are special instance methods, therefore, their first argument is always `this`. `locals` is the size of `local variables` array and `stack` is the size of `stack operand`, why their sizes are 1 I will write later.

> `Java` - `JVM` types table
>
> |  Java type  |  Byte code signature  |
> |:-:|:-:|
> | `void` | `V` |
> | `byte` | `B` |
> | `short` | `S` |
> | `char` | `C` |
> | `int` | `I` |
> | `float` | `F` |
> | `long` | `J` |
> | `double` | `D` |
> | `boolean` | `Z` |
> | `reference` | `L` |
> | `array` | `[` |
>

Each method has `local variables` array and `operand stack`. Their sizes computed during compilation. All method arguments are copied into `local variables` array, that is why its size is 1. `aload_0` loads element of `local variables` array with index `0`, which is `this`, onto `operand stack`. `invokespecial` pops the head of the `operand stack` and executes `<init>` method of `java.lang.Object` with it. After that `return` finish method invocation with `void` result.

> `<init>` stands for initialization and is a constructor. The line `java/lang/Object."<init>":()V` means invoke `new Object()`.

`sayHello` is simple method that I wrote just to show how `private` methods are invoked in byte code instruction. Let's have a look at `main` method.

```
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: new           #2       // class HelloWorld
         3: dup
         4: invokespecial #3       // Method "<init>":()V
         7: invokespecial #4       // Method sayHello:()V
        10: return
      LineNumberTable:
        line 3: 0
        line 4: 10
```

The byte code of `main` method is interesting. `new` operation allocates memory for our `HelloWorld` object and put reference onto stack, `dup` duplicates the first item on stack. The first `invokespecial` invoke `<init>` method with the first reference on `HelloWorld` and the second is invoke `sayHello` with the second reference.

`main` method stack looks like:

> `new`
>
>| Stack |
>|:-:|
>| `L HelloWorld` |
>
> `dup`
>
>| Stack |
>|:-:|
>| `L HelloWorld` |
>| `L HelloWorld` |
>
> `invokespecial "<init>":()V`
>
>| Stack |
>|:-:|
>| `L HelloWorld` |
>
> `invokespecial sayHello:()V`
>
>| Stack |
>|:-:|
>| |
